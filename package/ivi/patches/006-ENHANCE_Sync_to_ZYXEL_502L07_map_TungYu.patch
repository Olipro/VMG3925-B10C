Index: ivi-1.0/ivi_config.h
===================================================================
--- ivi-1.0.orig/ivi_config.h	2020-02-11 03:33:39.774453739 +0000
+++ ivi-1.0/ivi_config.h	2020-02-11 03:33:52.278453619 +0000
@@ -109,6 +109,7 @@
 	__u16 adjacent;
 	__u8 format;
 	__u8 transport;
+	__u8 extension;
 };
 
 #define MAPT_PORTMAP_TCP	0
@@ -119,6 +120,7 @@
 	__u32 lanAddr;
 	__u32 wanAddr;
 	__u16 port;
+	__u16 intPort;
 	__u16 proto;
 };
 
Index: ivi-1.0/ivi_ioctl.c
===================================================================
--- ivi-1.0.orig/ivi_ioctl.c	2020-02-11 03:33:39.794453738 +0000
+++ ivi-1.0/ivi_ioctl.c	2020-02-11 03:33:52.278453619 +0000
@@ -37,6 +37,7 @@
 #include <linux/module.h>
 #include <linux/ioctl.h>
 #include <linux/fs.h>
+#include <linux/cdev.h>
 #include <linux/netdevice.h>
 #include <linux/uaccess.h>
 
@@ -200,22 +201,27 @@
 				return -EACCES;
 			}
 			printk(KERN_INFO "ivi_ioctl: transport set to %d.\n", hgw_transport);
+			if (copy_from_user(&hgw_extension, (u8 *)arg + 1, sizeof(u8)) > 0) {
+				return -EACCES;
+			}
+			printk(KERN_INFO "ivi_ioctl: extension set to %d.\n", hgw_extension);
 			break;
 				
 		case IVI_IOC_ADD_PORTMAP:
 			{
-			u32 idx;
+			u32 idx, intPort;
 
 			if (copy_from_user(&portmap, (void *)arg, sizeof(struct portmap_info)) > 0)
 				return -EACCES;
 
+			intPort = portmap.intPort;
 			portmap.lanAddr = htonl(portmap.lanAddr);
 			portmap.wanAddr = htonl(portmap.wanAddr);
-			idx = mapportmap_lookup(&(portmap.lanAddr), portmap.wanAddr, portmap.port, 
+			idx = mapportmap_lookup(&(portmap.lanAddr), portmap.wanAddr, portmap.port, &intPort, 
 					portmap.proto, MAPPORTMAP_MODE_ADD);
 			if (idx == MAPPORTMAP_IX_INVALID) {
-				printk(KERN_DEBUG "ivi_ioctl: fail to insert portmap " NIP4_FMT NIP4_FMT "%d %d\n", 
-						NIP4(portmap.lanAddr), NIP4(portmap.wanAddr), portmap.port, portmap.proto);
+				printk(KERN_DEBUG "ivi_ioctl: fail to insert portmap " NIP4_FMT " " NIP4_FMT " %d %d %d\n", 
+						NIP4(portmap.lanAddr), NIP4(portmap.wanAddr), portmap.port, portmap.intPort, portmap.proto);
 				return -EINVAL;
 			}
 			break;
@@ -223,22 +229,23 @@
 			
 		case IVI_IOC_DEL_PORTMAP:
 			{
-			u32 idx;
+			u32 idx, intPort;
 
 			if (copy_from_user(&portmap, (void *)arg, sizeof(struct portmap_info)) > 0)
 				return -EACCES;
 
+			intPort = portmap.intPort;
 			portmap.lanAddr = htonl(portmap.lanAddr);
 			portmap.wanAddr = htonl(portmap.wanAddr);
-			idx = mapportmap_lookup(&(portmap.lanAddr), portmap.wanAddr, portmap.port, 
+			idx = mapportmap_lookup(&(portmap.lanAddr), portmap.wanAddr, portmap.port, &intPort, 
 					portmap.proto, MAPPORTMAP_MODE_DEL);
 			if (idx == MAPPORTMAP_IX_INVALID) {
-				printk(KERN_DEBUG "ivi_ioctl: fail to delete portmap, does not exist! " NIP4_FMT NIP4_FMT "%d %d\n", 
-						NIP4(portmap.lanAddr), NIP4(portmap.wanAddr), portmap.port, portmap.proto);
+				printk(KERN_DEBUG "ivi_ioctl: fail to delete portmap, does not exist! " NIP4_FMT " " NIP4_FMT " %d %d %d\n", 
+						NIP4(portmap.lanAddr), NIP4(portmap.wanAddr), portmap.port, portmap.intPort, portmap.proto);
 				return -EINVAL;
 			}
 			else
-				mapportmap_delete(idx);
+				mapportmap_delete(idx, portmap.proto);
 
 			break;
 			}
@@ -263,6 +270,11 @@
 	return 0;
 }
 
+static dev_t devno;
+static struct cdev ivi_cdev;
+static struct class *ivi_class = NULL;
+static struct device *ivi_device = NULL;
+
 struct file_operations ivi_ops = {
 	.owner		=	THIS_MODULE,
 	.unlocked_ioctl = ivi_ioctl,
@@ -275,17 +287,44 @@
 
 int ivi_ioctl_init(void) {
 	int retval;
-	if ((retval = register_chrdev(IVI_IOCTL, IVI_DEVNAME, &ivi_ops)) < 0) {
+	if ((retval = alloc_chrdev_region(&devno, 0, 1, IVI_DEVNAME)) < 0) {
 		printk(KERN_ERR "IVI: failed to register ioctl as character device, code %d.\n", retval);
 	}
+	if (IS_ERR(ivi_class = class_create(THIS_MODULE, IVI_DEVNAME))) {
+		retval = PTR_ERR(ivi_class);
+		printk(KERN_ERR "IVI: failed to create device class, code %d.\n", retval);
+		goto out_chrdev;
+	}
+	if (IS_ERR(ivi_device = device_create(ivi_class, NULL, devno, NULL, IVI_DEVNAME))) {
+		retval = PTR_ERR(ivi_device);
+		printk(KERN_ERR "IVI: failed to create device, code %d.\n", retval);
+		goto out_class;
+	}
+	cdev_init(&ivi_cdev, &ivi_ops);
+	ivi_cdev.owner = THIS_MODULE;
+	if ((retval = cdev_add(&ivi_cdev, devno, 1)) < 0) {
+		printk(KERN_ERR "IVI: failed to add driver, code %d.\n", retval);
+		goto out_device;
+	}
 #ifdef IVI_DEBUG
 	printk(KERN_DEBUG "IVI: ivi_ioctl loaded with return value %d.\n", retval);
 #endif
+	goto out;
+out_device:
+	device_destroy(ivi_class, devno);
+out_class:
+	class_destroy(ivi_class);
+out_chrdev:
+	unregister_chrdev_region(devno, 1);
+out:
 	return retval;
 }
 
 void ivi_ioctl_exit(void) {
-	unregister_chrdev(IVI_IOCTL, IVI_DEVNAME);
+	cdev_del(&ivi_cdev);
+	device_destroy(ivi_class, devno);
+	class_destroy(ivi_class);
+	unregister_chrdev_region(devno, 1);
 #ifdef IVI_DEBUG
 	printk(KERN_DEBUG "IVI: ivi_ioctl unloaded.\n");
 #endif
Index: ivi-1.0/ivi_ioctl.h
===================================================================
--- ivi-1.0.orig/ivi_ioctl.h	2020-02-11 03:33:39.770453739 +0000
+++ ivi-1.0/ivi_ioctl.h	2020-02-11 03:33:52.278453619 +0000
@@ -42,8 +42,6 @@
 
 #define IVI_DEVNAME	"ivi"
 
-#define IVI_IOCTL	3015
-
 typedef enum IviIoctl
 {
     IVI_IOC_DUMMY = 999,
Index: ivi-1.0/ivi_map.c
===================================================================
--- ivi-1.0.orig/ivi_map.c	2020-02-11 03:33:39.750453739 +0000
+++ ivi-1.0/ivi_map.c	2020-02-11 03:33:52.278453619 +0000
@@ -86,6 +86,7 @@
 	}
 	list->size = 0;
 	list->port_num = 0;
+	list->portmap_num = 0;
 	list->last_alloc_port = 0;
 	list->timeout = timeout;
 	list->type = type;
@@ -115,7 +116,7 @@
 }
 
 // Add a new map, the pointer to the new map_tuple is returned on success, must be protected by spin lock when calling this function
-static struct map_tuple* add_new_map(__be32 oldaddr, __be16 oldp, __be32 dstaddr, __be16 newp, struct map_list *list)
+static struct map_tuple* add_new_map(u32 portmapidx, __be32 oldaddr, __be16 oldp, __be32 dstaddr, __be16 newp, struct map_list *list)
 {
 	struct map_tuple *map;
 	int hash;
@@ -125,6 +126,7 @@
 		return NULL;
 	}
 
+	map->portmapidx = portmapidx;
 	map->oldaddr = oldaddr;
 	map->oldport = oldp;
 	map->dstaddr = dstaddr;
@@ -148,7 +150,7 @@
 }
 
 // Refresh the timer for each map_tuple, must NOT acquire spin lock when calling this function
-void refresh_map_list(struct map_list *list)
+void refresh_map_list(struct map_list *list, u32 portmapidx)
 {
 	struct map_tuple *iter, *i0;
 	struct hlist_node *loop, *l0;
@@ -158,38 +160,48 @@
 	do_gettimeofday(&now);
 	
 	spin_lock_bh(&list->lock);
+	if (portmapidx != MAPPORTMAP_IX_INVALID && list->portmap_num == 0) {
+		spin_unlock_bh(&list->lock);
+		return;
+	}
 	// Iterate all the map_tuple through out_chain only, in_chain contains the same info.
 	for (i = 0; i < IVI_HTABLE_SIZE; i++) {
 		hlist_for_each_entry_safe(iter, loop, &list->out_chain[i], out_node) {
-			delta = now.tv_sec - iter->timer.tv_sec;
-			if (delta >= list->timeout) {
+			if (portmapidx == MAPPORTMAP_IX_INVALID)
+				delta = now.tv_sec - iter->timer.tv_sec;
+			else if (portmapidx != iter->portmapidx)
+				continue;
+
+			if (portmapidx != MAPPORTMAP_IX_INVALID || delta >= list->timeout) {
 #if defined(CONFIG_BCM_KF_BLOG) && defined(CONFIG_BLOG)
-	            blog_lock();
-                if (iter->blog_key[BLOG_PARAM1_MAP_DIR_US] != BLOG_KEY_FC_INVALID || 
-		            iter->blog_key[BLOG_PARAM1_MAP_DIR_DS] != BLOG_KEY_FC_INVALID) {
-		            if (blog_query(QUERY_MAP_TUPLE, (void*)iter, 
-                            iter->blog_key[BLOG_PARAM1_MAP_DIR_US],
-                            iter->blog_key[BLOG_PARAM1_MAP_DIR_DS], 0)) {
-	                    blog_unlock();
-                        continue;
-                    }
-                }
-                else {
-                    // flow cache flow might have disassociated itself from map tuple.
-                    if (iter->evict_time.tv_sec) {
-			            iter->timer.tv_sec = iter->evict_time.tv_sec;
-			            delta = now.tv_sec - iter->timer.tv_sec;
-			            if (delta < list->timeout) {
-	                        blog_unlock();
-                            continue;
-                        }
-                    }
-                }
-	            blog_unlock();
+				if (portmapidx == MAPPORTMAP_IX_INVALID) {
+					blog_lock();
+					if (iter->blog_key[BLOG_PARAM1_MAP_DIR_US] != BLOG_KEY_FC_INVALID || 
+					    iter->blog_key[BLOG_PARAM1_MAP_DIR_DS] != BLOG_KEY_FC_INVALID) {
+						if (blog_query(QUERY_MAP_TUPLE, (void*)iter, 
+						            iter->blog_key[BLOG_PARAM1_MAP_DIR_US],
+						            iter->blog_key[BLOG_PARAM1_MAP_DIR_DS], 0)) {
+							blog_unlock();
+							continue;
+						}
+					}
+					else {
+						// flow cache flow might have disassociated itself from map tuple.
+						if (iter->evict_time.tv_sec) {
+							iter->timer.tv_sec = iter->evict_time.tv_sec;
+							delta = now.tv_sec - iter->timer.tv_sec;
+							if (delta < list->timeout) {
+								blog_unlock();
+								continue;
+							}
+						}
+					}
+					blog_unlock();
+				}
 #endif
 
 #ifdef IVI_DEBUG_MAP
-				printk(KERN_INFO "refresh_map_list: time out map " NIP4_FMT ":%d -> " NIP4_FMT " ------> %d on out_chain[%d]\n", NIP4(iter->oldaddr), iter->oldport, NIP4(iter->dstaddr), iter->newport, i);
+				printk(KERN_INFO "refresh_map_list: %s map " NIP4_FMT ":%d -> " NIP4_FMT " ------> %d on out_chain[%d]\n", portmapidx == MAPPORTMAP_IX_INVALID ? "time out" : "delete", NIP4(iter->oldaddr), iter->oldport, NIP4(iter->dstaddr), iter->newport, i);
 #endif
 
 				hlist_del(&iter->out_node);
@@ -215,19 +227,22 @@
  				}
 
 #if defined(CONFIG_BCM_KF_BLOG) && defined(CONFIG_BLOG)
-	            blog_lock();
-                if (iter->blog_key[BLOG_PARAM1_MAP_DIR_US] != BLOG_KEY_FC_INVALID || 
-		            iter->blog_key[BLOG_PARAM1_MAP_DIR_DS] != BLOG_KEY_FC_INVALID) {
-		            blog_notify(DESTROY_MAP_TUPLE, (void*)iter, 
-                            iter->blog_key[BLOG_PARAM1_MAP_DIR_US],
-                            iter->blog_key[BLOG_PARAM1_MAP_DIR_DS]);
-                    iter->blog_key[BLOG_PARAM1_MAP_DIR_US] = BLOG_KEY_FC_INVALID;
-                    iter->blog_key[BLOG_PARAM1_MAP_DIR_DS] = BLOG_KEY_FC_INVALID;
-                }
-	            blog_unlock();
+				blog_lock();
+				if (iter->blog_key[BLOG_PARAM1_MAP_DIR_US] != BLOG_KEY_FC_INVALID || 
+				    iter->blog_key[BLOG_PARAM1_MAP_DIR_DS] != BLOG_KEY_FC_INVALID) {
+					blog_notify(DESTROY_MAP_TUPLE, (void*)iter, 
+					            iter->blog_key[BLOG_PARAM1_MAP_DIR_US],
+					            iter->blog_key[BLOG_PARAM1_MAP_DIR_DS]);
+				}
+				blog_unlock();
 #endif
 
 				kfree(iter);
+
+				if (portmapidx != MAPPORTMAP_IX_INVALID && --list->portmap_num == 0) {
+					spin_unlock_bh(&list->lock);
+					return;
+				}
 			}
 		}
 	}
@@ -250,12 +265,25 @@
 			hlist_del(&iter->dest_node);
 			list->size--;
 			
+#ifdef IVI_DEBUG_MAP
 			printk(KERN_INFO "free_map_list: delete map " NIP4_FMT ":%d -> " NIP4_FMT " ------> %d on out_chain[%d]\n", NIP4(iter->oldaddr), iter->oldport, NIP4(iter->dstaddr), iter->newport, i);
-			
+#endif
+#if defined(CONFIG_BCM_KF_BLOG) && defined(CONFIG_BLOG)
+            blog_lock();
+            if (iter->blog_key[BLOG_PARAM1_MAP_DIR_US] != BLOG_KEY_FC_INVALID || 
+                iter->blog_key[BLOG_PARAM1_MAP_DIR_DS] != BLOG_KEY_FC_INVALID) {
+                blog_notify(DESTROY_MAP_TUPLE, (void*)iter, 
+                            iter->blog_key[BLOG_PARAM1_MAP_DIR_US],
+                            iter->blog_key[BLOG_PARAM1_MAP_DIR_DS]);
+			}
+            blog_unlock();
+#endif
+
 			kfree(iter);
 		}
 	}
 	list->port_num = 0;
+	list->portmap_num = 0;
 	spin_unlock_bh(&list->lock);
 }
 
@@ -279,7 +307,7 @@
 	adjacent = fls(adjacent) - 1;
 	start_port = ((1 << (ratio + adjacent)) > 1024) ? 1 << (ratio + adjacent) : 1024; // the ports below start_port are reserved for system ports.
 	
-	refresh_map_list(list);
+	refresh_map_list(list, MAPPORTMAP_IX_INVALID);
 	spin_lock_bh(&list->lock);
 	
 	hash = v4addr_port_hashfn(oldaddr, oldp);
@@ -373,7 +401,9 @@
 			// If it's so lucky to reach here, we have to generate a new port	
 			if (get_list_port_num(list) >= ((65536 - start_port)>>ratio)) {
 				spin_unlock_bh(&list->lock);
+#ifdef IVI_DEBUG_MAP
 				printk(KERN_INFO "get_outflow_map_port: map list full.\n");
+#endif
 				return -1;
 			}
 
@@ -429,7 +459,7 @@
 		}
 	}
 	
-	tuple = add_new_map(oldaddr, oldp, dstaddr, retport, list);
+	tuple = add_new_map(MAPPORTMAP_IX_INVALID, oldaddr, oldp, dstaddr, retport, list);
 
 	if (tuple == NULL) {
 		spin_unlock_bh(&list->lock);
@@ -461,7 +491,7 @@
 	struct map_tuple *iter;
 	int ret, hash;
 		
-	refresh_map_list(list);
+	refresh_map_list(list, MAPPORTMAP_IX_INVALID);
 	spin_lock_bh(&list->lock);
 	
 	ret = 1;
@@ -488,18 +518,19 @@
 	}
 	
 	if (ret == 1) {	// fail to find a mapping either in list.
-		u32 idx;
+		u32 idx, oldp0 = 0;
 #ifdef IVI_DEBUG_MAP
 		printk(KERN_INFO "get_inflow_map_port: in_chain[%d] empty.\n", hash);
 #endif
 		
-		idx = mapportmap_lookup(oldaddr, dstaddr, newp, (1<<MAPPORTMAP_PROTO_UDP), MAPPORTMAP_MODE_FIND);
+		idx = mapportmap_lookup(oldaddr, dstaddr, newp, &oldp0, (1<<list->type), MAPPORTMAP_MODE_FIND);
 		if (idx != MAPPORTMAP_IX_INVALID) {
 			struct map_tuple *tuple = NULL;
 
-			*oldp = newp;
-			if ((tuple=add_new_map(*oldaddr, *oldp, dstaddr, newp, list)) != NULL) {
+			*oldp = oldp0;
+			if ((tuple=add_new_map(idx, *oldaddr, *oldp, dstaddr, newp, list)) != NULL) {
 				list->last_alloc_port = newp;
+				list->portmap_num++;
 				list->port_num++;
 #if defined(CONFIG_BCM_KF_BLOG) && defined(CONFIG_BLOG)
 				blog_link(MAP_TUPLE, blog_ptr(skb), (void*)tuple, BLOG_PARAM1_MAP_DIR_DS, 0);
@@ -532,6 +563,7 @@
     {
         frag_p = (MapFrag_t*)dll_head_p(&mapfragment.frlist);
         dll_delete(&frag_p->node);
+        dll_init(&frag_p->node);
     }
 
     return frag_p;
@@ -630,13 +662,12 @@
 static void mapfrag_free( MapFrag_t * frag_p )
 {
     frag_p->ipid = 0;
-    frag_p->isdefrag4 = 0;
     frag_p->v4addr = 0;
     memset((void *)&(frag_p->v6addr), 0, sizeof(struct in6_addr));
     frag_p->timer.tv_sec = 0;
     frag_p->timer.tv_usec = 0;
+    frag_p->chain_p = MAPFRAG_NULL;
 
-    dll_delete( &frag_p->node );
     dll_prepend(&mapfragment.frlist, &frag_p->node);
 }
 
@@ -699,12 +730,11 @@
     return idx;
 }
 
-void mapfrag_get( u32 idx, u32 *isdefrag4, __be32 *v4addr, struct timeval *timer )
+void mapfrag_get( u32 idx, __be32 *v4addr, struct timeval *timer )
 {
     MapFrag_t * frag_p;
 
     frag_p = &mapfragment.etable[idx];
-		*isdefrag4 = frag_p->isdefrag4;
     *v4addr = frag_p->v4addr;
     timer->tv_sec = frag_p->timer.tv_sec;
     timer->tv_usec = frag_p->timer.tv_usec;
@@ -712,12 +742,11 @@
     return;
 }
 
-void mapfrag_set( u32 idx, u32 isdefrag4, __be32 v4addr )
+void mapfrag_set( u32 idx, __be32 v4addr )
 {
     MapFrag_t * frag_p;
 
     frag_p = &mapfragment.etable[idx];
-    frag_p->isdefrag4 = isdefrag4;
     frag_p->v4addr = v4addr;
 
     return;
Index: ivi-1.0/ivi_map.h
===================================================================
--- ivi-1.0.orig/ivi_map.h	2020-02-11 03:33:39.782453738 +0000
+++ ivi-1.0/ivi_map.h	2020-02-11 03:33:52.278453619 +0000
@@ -59,6 +59,7 @@
 	struct hlist_node out_node;  // Inserted to out_chain
 	struct hlist_node in_node;   // Inserted to in_chain
 	struct hlist_node dest_node;   // Inserted to dest_chain
+	u32 portmapidx;
 	__be32 oldaddr;
 	__be16 oldport;
 	__be32 dstaddr;
@@ -74,6 +75,7 @@
 	struct hlist_head dest_chain[IVI_HTABLE_SIZE]; // Map table with destination and newport
 	int size;
 	int port_num;            // Number of MAP ports allocated in the map list
+	int portmap_num;         // Number of MAP ports used for port forwarding
 	__be16 last_alloc_port;  // Save the last allocate port number
 	time_t timeout;
 	int type;
@@ -90,15 +92,14 @@
 
 	u32 idx;
 	u32 ipid;
-	u32 isdefrag4;
 	struct in6_addr v6addr;
 	__be32 v4addr;
 	struct timeval timer;
 } __attribute__ ((packed)) MapFrag_t;
 
 extern u32 mapfrag_lookup( const struct in6_addr *v6addr, u32 ipid );
-extern void mapfrag_get( u32 idx, u32 *isdefrag4, __be32 * v4addr, struct timeval *timer );
-extern void mapfrag_set( u32 idx, u32 isdefrag4, __be32 v4addr );
+extern void mapfrag_get( u32 idx, __be32 * v4addr, struct timeval *timer );
+extern void mapfrag_set( u32 idx, __be32 v4addr );
 extern void mapfrag_delete( u32 ipid );
 extern int init_mapfrag_list( time_t timeout );
 
@@ -115,7 +116,7 @@
 
 
 /* list operations */
-extern void refresh_map_list(struct map_list *list);
+extern void refresh_map_list(struct map_list *list, u32 portmapidx);
 extern void free_map_list(struct map_list *list);
 
 /* mapping operations */
Index: ivi-1.0/ivi_map_tcp.c
===================================================================
--- ivi-1.0.orig/ivi_map_tcp.c	2020-02-11 03:33:39.742453739 +0000
+++ ivi-1.0/ivi_map_tcp.c	2020-02-11 03:33:52.278453619 +0000
@@ -888,8 +888,6 @@
 		            blog_notify(DESTROY_MAP_TUPLE, (void*)iter, 
                             iter->blog_key[BLOG_PARAM1_MAP_DIR_US],
                             iter->blog_key[BLOG_PARAM1_MAP_DIR_DS]);
-                    iter->blog_key[BLOG_PARAM1_MAP_DIR_US] = BLOG_KEY_FC_INVALID;
-                    iter->blog_key[BLOG_PARAM1_MAP_DIR_DS] = BLOG_KEY_FC_INVALID;
                 }
 	            blog_unlock();
 #endif
Index: ivi-1.0/ivi_nf.c
===================================================================
--- ivi-1.0.orig/ivi_nf.c	2020-02-11 03:33:39.786453738 +0000
+++ ivi-1.0/ivi_nf.c	2020-02-11 03:33:52.278453619 +0000
@@ -39,61 +39,31 @@
 
 static int running;
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,29 ))
-unsigned int nf_hook4(unsigned int hooknum, struct sk_buff *skb,
-		const struct net_device *in, const struct net_device *out,
-		int (*okfn)(struct sk_buff *)) {
-#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 3,18,21 ))
-static unsigned int nf_hook4(const struct nf_hook_ops *ops, struct sk_buff *skb,
-		const struct net_device *in, const struct net_device *out,
-		int (*okfn)(struct sk_buff *)) {
-#else
 static unsigned int nf_hook4(const struct nf_hook_ops *ops,
-		struct sk_buff *skb,
-		const struct nf_hook_state *state) {
-#endif
+                            struct sk_buff *skb,
+    		                const struct nf_hook_state *state) {
 	unsigned int ret;
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 3,18,21 ))
-	if ((!running) || (in != v4_dev)) {
-#else
 	if ((!running) || (state->in != v4_dev)) {
-#endif
 		return NF_ACCEPT;
 	}
 
-	ret = ivi_v4v6_xmit(skb, v6_dev->mtu);
+	ret = ivi_v4v6_xmit(skb, v6_dev->mtu, v4_dev->mtu);
 
 	if (ret == 0)
 		return NF_DROP;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,1,51 ))
 	else if (ret == NF_STOLEN)
 		return NF_STOLEN;
 	else
-#endif
 		return NF_ACCEPT;
 }
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 2,6,29 ))
-unsigned int nf_hook6(unsigned int hooknum, struct sk_buff *skb,
-		const struct net_device *in, const struct net_device *out,
-		int (*okfn)(struct sk_buff *)) {
-#elif (LINUX_VERSION_CODE <= KERNEL_VERSION( 3,18,21 ))
-static unsigned int nf_hook6(const struct nf_hook_ops *ops, struct sk_buff *skb,
-		const struct net_device *in, const struct net_device *out,
-		int (*okfn)(struct sk_buff *)) {
-#else
 static unsigned int nf_hook6(const struct nf_hook_ops *ops,
-		struct sk_buff *skb,
-		const struct nf_hook_state *state) {
-#endif
+                            struct sk_buff *skb,
+    		                const struct nf_hook_state *state) {
 	unsigned int ret;
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION( 3,18,21 ))
-	if ((!running) || (in != v6_dev)) {
-#else
 	if ((!running) || (state->in != v6_dev)) {
-#endif
 		return NF_ACCEPT;
 	}
 
@@ -101,11 +71,9 @@
 
 	if (ret == 0)
 		return NF_DROP;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION( 4,1,51 ))
 	else if (ret == NF_STOLEN)
 		return NF_STOLEN;
 	else
-#endif
 		return NF_ACCEPT;
 }
 
Index: ivi-1.0/ivi_nf.h
===================================================================
--- ivi-1.0.orig/ivi_nf.h	2020-02-11 03:33:39.734453739 +0000
+++ ivi-1.0/ivi_nf.h	2020-02-11 03:33:52.278453619 +0000
@@ -37,7 +37,6 @@
 #ifndef IVI_NF_H
 #define IVI_NF_H
 
-#include <linux/version.h>
 #include <linux/module.h>
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv4.h>
Index: ivi-1.0/ivi_portmap.c
===================================================================
--- ivi-1.0.orig/ivi_portmap.c	2020-02-11 03:33:39.798453738 +0000
+++ ivi-1.0/ivi_portmap.c	2020-02-11 03:33:52.278453619 +0000
@@ -43,6 +43,7 @@
     {
         pmap_p = (MapPortmap_t*)dll_head_p(&mapportmapping.frlist);
         dll_delete(&pmap_p->node);
+        dll_init(&pmap_p->node);
     }
 
     return pmap_p;
@@ -68,21 +69,24 @@
 
 static inline u32 _mapportmap_match( const MapPortmap_t *pmap_p,
                                   u32 *lanAddr, u32 wanAddr, u32 port,
-                                  u32 proto, int mode )
+                                  u32 *intPort, u32 proto, int mode )
 {
 	if ((mode == MAPPORTMAP_MODE_ADD) || (mode == MAPPORTMAP_MODE_DEL)) {
     	return ((pmap_p->info.lanAddr == *lanAddr) && 
 				(pmap_p->info.wanAddr == wanAddr) &&
+				(pmap_p->info.intPort == *intPort) &&
 				(pmap_p->info.port == port) && (pmap_p->info.proto == proto));
 	}
 	else {
+		u32 test = *intPort ? ((pmap_p->info.intPort == *intPort) ? 1 : 0) : 1;
+
 		if (pmap_p->info.wanAddr != MAPPORTMAP_INVALID_ADDRESS) 
 			return ((pmap_p->info.wanAddr == wanAddr) &&
 					(pmap_p->info.port == port) && 
-					(pmap_p->info.proto & proto));
+					(pmap_p->info.proto & proto) && test);
 		else
 			return ((pmap_p->info.port == port) && 
-					(pmap_p->info.proto & proto));
+					(pmap_p->info.proto & proto) && test);
 	}
 }
 
@@ -105,7 +109,7 @@
 	}
 }
 
-static u32 mapportmap_new( u32 *lanAddr, u32 wanAddr, u32 port, u32 proto, u32 hashix )
+static u32 mapportmap_new( u32 *lanAddr, u32 wanAddr, u32 port, u32 *intPort, u32 proto, u32 hashix )
 {
     MapPortmap_t * pmap_p;
 
@@ -122,6 +126,7 @@
     pmap_p->info.lanAddr = *lanAddr;
     pmap_p->info.wanAddr = wanAddr;
     pmap_p->info.port = port;
+    pmap_p->info.intPort = *intPort;
     pmap_p->info.proto = proto;
     mapportmap_hashin(pmap_p, hashix);
 
@@ -174,12 +179,12 @@
     pmap_p->info.wanAddr = 0;
     pmap_p->info.port = 0;
     pmap_p->info.proto = 0;
+    pmap_p->chain_p = MAPPORTMAP_NULL;
 
-    dll_delete( &pmap_p->node );
     dll_prepend(&mapportmapping.frlist, &pmap_p->node);
 }
 
-void mapportmap_delete( u32 idx )
+void mapportmap_delete( u32 idx, u32 proto )
 {
     MapPortmap_t * pmap_p;
     u32 hashix;
@@ -189,9 +194,18 @@
 
     mapportmap_unhash(pmap_p, hashix);
     mapportmap_free(pmap_p);
+
+    if (proto & (1 << MAPPORTMAP_PROTO_TCP))
+        refresh_map_list(&tcp_list, idx);
+
+    if (proto & (1 << MAPPORTMAP_PROTO_UDP))
+        refresh_map_list(&udp_list, idx);
+
+    if (proto & (1 << MAPPORTMAP_PROTO_ICMP))
+        refresh_map_list(&icmp_list, idx);
 }
 
-u32 mapportmap_lookup( u32 *lanAddr, u32 wanAddr, u32 port, u32 proto, int mode )
+u32 mapportmap_lookup( u32 *lanAddr, u32 wanAddr, u32 port, u32 *intPort, u32 proto, int mode )
 {
     MapPortmap_t * pmap_p;
     u32 idx;
@@ -202,16 +216,18 @@
     for ( pmap_p = mapportmapping.htable[ hashix ]; pmap_p != MAPPORTMAP_NULL;
           pmap_p = pmap_p->chain_p)
     {
-        if (likely( _mapportmap_match(pmap_p, lanAddr, wanAddr, port, proto, mode) )) {
-			if (mode == MAPPORTMAP_MODE_FIND)
+        if (likely( _mapportmap_match(pmap_p, lanAddr, wanAddr, port, intPort, proto, mode) )) {
+			if (mode == MAPPORTMAP_MODE_FIND) {
 				*lanAddr = pmap_p->info.lanAddr;
+				*intPort = pmap_p->info.intPort;
+			}
 
             return pmap_p->idx;
 		}
     }
 
 	if (mode == MAPPORTMAP_MODE_ADD)
-		idx = mapportmap_new(lanAddr, wanAddr, port, proto, hashix);
+		idx = mapportmap_new(lanAddr, wanAddr, port, intPort, proto, hashix);
 	else
 		idx = MAPPORTMAP_IX_INVALID;
 
Index: ivi-1.0/ivi_portmap.h
===================================================================
--- ivi-1.0.orig/ivi_portmap.h	2020-02-11 03:33:39.758453739 +0000
+++ ivi-1.0/ivi_portmap.h	2020-02-11 03:33:52.278453619 +0000
@@ -50,8 +50,8 @@
 	struct portmap_info info;
 } __attribute__ ((packed)) MapPortmap_t;
 
-extern u32 mapportmap_lookup( u32 *lanAddr, u32 wanAddr, u32 port, u32 proto, int mode );
-extern void mapportmap_delete( u32 idx );
+extern u32 mapportmap_lookup( u32 *lanAddr, u32 wanAddr, u32 port, u32 *intPort, u32 proto, int mode );
+extern void mapportmap_delete( u32 idx, u32 proto );
 extern int mapportmap_port( u16 port, int type );
 extern int init_mapportmap_list(void);
 
Index: ivi-1.0/ivi_rule.c
===================================================================
--- ivi-1.0.orig/ivi_rule.c	2020-02-11 03:33:39.802453738 +0000
+++ ivi-1.0/ivi_rule.c	2020-02-11 03:33:52.278453619 +0000
@@ -77,6 +77,7 @@
 	u16 adjacent;
 	u8 format;
 	u8 transport;
+	u8 extension;
 };
 
 struct tleaf {
@@ -655,7 +656,7 @@
 	return NULL;
 }
 
-static int check_leaf(struct tleaf *l, t_key key, struct in6_addr *prefix6, int *plen4, int *plen6, u16 *ratio, u16 *adjacent, u8 *fmt, u8 *transpt)
+static int check_leaf(struct tleaf *l, t_key key, struct in6_addr *prefix6, int *plen4, int *plen6, u16 *ratio, u16 *adjacent, u8 *fmt, u8 *transpt, u8 *ext6)
 {
 	struct tleaf_info *li;
 	struct hlist_head *head = &l->head;
@@ -674,9 +675,11 @@
 				*fmt = li->format;
 			if (transpt)
 				*transpt = li->transport;
+			if (ext6)
+				*ext6 = li->extension;
 #ifdef IVI_DEBUG_RULE
-			printk(KERN_DEBUG "ivi_rule_lookup: " NIP4_FMT "/%d -> " NIP6_FMT "/%d, ratio = %d, adjacent = %d, addr-format %d, transport %d\n", 
-				NIP4(key), li->plen, NIP6(li->prefix6), li->prefix6_len, li->ratio, li->adjacent, li->format, li->transport);
+			printk(KERN_DEBUG "ivi_rule_lookup: " NIP4_FMT "/%d -> " NIP6_FMT "/%d, ratio = %d, adjacent = %d, addr-format %d, transport %d, extension %d\n", 
+				NIP4(key), li->plen, NIP6(li->prefix6), li->prefix6_len, li->ratio, li->adjacent, li->format, li->transport, li->extension);
 #endif
 			return 0;
 		}
@@ -684,7 +687,7 @@
 	return 1;
 }
 
-int ivi_rule_lookup(u32 key, struct in6_addr *prefix6, int *plen4, int *plen6, u16 *ratio, u16 *adjacent, u8 *fmt, u8 *transpt)
+int ivi_rule_lookup(u32 key, struct in6_addr *prefix6, int *plen4, int *plen6, u16 *ratio, u16 *adjacent, u8 *fmt, u8 *transpt, u8 *ext6)
 {
 	int ret;
 	struct tentry *n;
@@ -704,7 +707,7 @@
 
 	/* Just a leaf? */
 	if (IS_LEAF(n)) {
-		ret = check_leaf((struct tleaf *)n, key, prefix6, plen4, plen6, ratio, adjacent, fmt, transpt);
+		ret = check_leaf((struct tleaf *)n, key, prefix6, plen4, plen6, ratio, adjacent, fmt, transpt, ext6);
 		goto found;
 	}
 
@@ -725,7 +728,7 @@
 		}
 
 		if (IS_LEAF(n)) {
-			ret = check_leaf((struct tleaf *)n, key, prefix6, plen4, plen6, ratio, adjacent, fmt, transpt);
+			ret = check_leaf((struct tleaf *)n, key, prefix6, plen4, plen6, ratio, adjacent, fmt, transpt, ext6);
 			if (ret > 0)
 				goto backtrace;
 			goto found;
@@ -918,6 +921,7 @@
 		li->adjacent = rule->adjacent;
 		li->format = rule->format;
 		li->transport = rule->transport;
+		li->extension = rule->extension;
 	} else {
 		li = trie_insert_node(key, plen);
 		// Insert satellite data.
@@ -927,11 +931,12 @@
 		li->adjacent = rule->adjacent;
 		li->format = rule->format;
 		li->transport = rule->transport;
+		li->extension = rule->extension;
 	}
 	spin_unlock_bh(&trie_lock);
 #ifdef IVI_DEBUG_RULE
-	printk(KERN_DEBUG "ivi_rule_insert: " NIP4_FMT "/%d -> " NIP6_FMT "/%d, ratio %d, adjacent %d, addr-format %d, transport %d\n", 
-		NIP4(rule->prefix4), rule->plen4, NIP6(rule->prefix6), rule->plen6, rule->ratio, rule->adjacent, rule->format, rule->transport);
+	printk(KERN_DEBUG "ivi_rule_insert: " NIP4_FMT "/%d -> " NIP6_FMT "/%d, ratio %d, adjacent %d, addr-format %d, transport %d, extension %d\n", 
+		NIP4(rule->prefix4), rule->plen4, NIP6(rule->prefix6), rule->plen6, rule->ratio, rule->adjacent, rule->format, rule->transport, rule->extension);
 #endif
 	return 0;
 }
Index: ivi-1.0/ivi_rule.h
===================================================================
--- ivi-1.0.orig/ivi_rule.h	2020-02-11 03:33:39.722453739 +0000
+++ ivi-1.0/ivi_rule.h	2020-02-11 03:33:52.278453619 +0000
@@ -48,7 +48,7 @@
 
 #include "ivi_config.h"
 
-extern int ivi_rule_lookup(u32 key, struct in6_addr *prefix6, int *plen4, int *plen6, u16 *ratio, u16 *adjacent, u8 *fmt, u8 *transpt);
+extern int ivi_rule_lookup(u32 key, struct in6_addr *prefix6, int *plen4, int *plen6, u16 *ratio, u16 *adjacent, u8 *fmt, u8 *transpt, u8 *ext6);
 extern int ivi_rule_insert(struct rule_info *rule);
 extern int ivi_rule_delete(struct rule_info *rule);
 extern void ivi_rule_flush(void);
Index: ivi-1.0/ivi_xmit.c
===================================================================
--- ivi-1.0.orig/ivi_xmit.c	2020-02-11 03:33:39.754453739 +0000
+++ ivi-1.0/ivi_xmit.c	2020-02-11 03:33:52.278453619 +0000
@@ -79,6 +79,8 @@
 
 u8 hgw_transport = 0;  // header manipulation manner
 
+u8 hgw_extension = 0;  // IPv6 header options
+
 u16 mss_limit = 1432;  // max mss supported
 
 
@@ -101,11 +103,11 @@
 	memset(v6addr, 0, sizeof(struct in6_addr));
 
 	if (_dir == ADDR_DIR_DST) {		
-		if (ivi_rule_lookup(addr, v6addr, &plen4, &prefixlen, &ratio, &adjacent, &fmt, transpt) != 0) {
+		if (ivi_rule_lookup(addr, v6addr, &plen4, &prefixlen, &ratio, &adjacent, &fmt, transpt, NULL) != 0) {
 			printk(KERN_DEBUG "ipaddr_4to6: failed to map v4 addr " NIP4_FMT "\n", NIP4(addr));
 			return -1;
 		}
-
+		
 		// when *transpt is set to MAP_E, an /128 IPv6 destination address is used in encapsulation header.
 		if (*transpt == MAP_E) 
 			return 0;
@@ -238,9 +240,7 @@
 			break;
 		}
 	}
-#ifdef IVI_DEBUG //TungYu
-		printk(KERN_INFO"%s: fmt=%d " NIP6_FMT " prefixlen=%d " NIP4_FMT " \n", __FUNCTION__, fmt, NIP6(*v6addr), prefixlen, NIP4(addr));
-#endif
+
 	return 0;
 }
 
@@ -269,7 +269,7 @@
 		return -1;
 	}
 	
-	if (_dir == ADDR_DIR_DST) {
+	if (_dir == ADDR_DIR_DST) {		
 		addr |= ((unsigned int)v6addr->s6_addr[10]) << 24;
 		addr |= ((unsigned int)v6addr->s6_addr[11]) << 16;
 		addr |= ((unsigned int)v6addr->s6_addr[12]) << 8;
@@ -426,7 +426,8 @@
 	return ((__force u16)csum32);
 }
 
-int ivi_v4v6_xmit(struct sk_buff *skb, unsigned int mtu) {
+int ivi_v4v6_xmit(struct sk_buff *skb, unsigned int mtu, unsigned int _mtu) {
+	struct net_device *orig_dev;
 	struct sk_buff *newskb;
 	struct ethhdr *eth4, *eth6;
 	struct iphdr *ip4h;
@@ -439,9 +440,11 @@
 	__u8 *payload;
 	unsigned int hlen, plen;
 	u16 newp, s_port, d_port;
-	u8 transport;
+	u8 transport = 0;
+	u8 extension = 0;
 	char flag_udp_nullcheck;
 	u8 frag_mode = 0;
+	struct in6_addr tempaddr;
 	
 	eth4 = eth_hdr(skb);
 	if (unlikely(eth4->h_proto != __constant_ntohs(ETH_P_IP))) {
@@ -480,76 +483,41 @@
 	if (ip4h->ttl <= 1) {
 		return -EINVAL;  // Just accept.
 	}
+
+	if (ivi_rule_lookup(ntohl(ip4h->daddr), &tempaddr, NULL, NULL, NULL, NULL, NULL, &transport, &extension) != 0) {
+#ifdef IVI_DEBUG
+		printk(KERN_DEBUG "ivi_v4v6_xmit: transport/extension lookup failure.\n");
+#endif
+		return -EINVAL;  // Just accept.
+	}
 	
-	if (ip4h->protocol == IPPROTO_ICMP || (hgw_transport == MAP_E && ip4h->protocol == IPPROTO_UDP)) {
+	if (transport == MAP_E || ip4h->protocol == IPPROTO_ICMP) {
 		if ((ip4h->frag_off & htons(IP_MF)) || (ip4h->frag_off & htons(IP_OFFSET))) {
-			u32 isdefrag4 = 0;
 			int err;
 
-			if (hgw_transport == MAP_E && ip4h->protocol == IPPROTO_UDP) {
-				struct in6_addr v6addr;
-				u32 idx, ipid;
-
-				ipv6_addr_set_v4mapped(ip4h->saddr, &v6addr);
-				ipid = ntohs(ip4h->id);
-
-				if (!(ip4h->frag_off & htons(IP_OFFSET))) {
-					u16 len_assembled, len_each;
-
-					payload = (__u8 *)(ip4h) + (ip4h->ihl << 2);
-					udph = (struct udphdr *)payload;
-					len_assembled = ntohs(udph->len) + sizeof(struct ipv6hdr) + 8/* dest(8) */ + sizeof(struct iphdr);
-					len_each = ntohs(ip4h->tot_len) + sizeof(struct ipv6hdr) + 8/* dest(8) */;
-
-					if (len_assembled <= mtu || len_each > mtu)
-						isdefrag4 = 1;
-
-					if ((idx = mapfrag_lookup(&v6addr, ipid)) != MAPFRAG_IX_INVALID) {
-						mapfrag_set(idx, isdefrag4, ip4h->saddr);
-					}
-				}
-				else if ((idx = mapfrag_lookup(&v6addr, ipid)) != MAPFRAG_IX_INVALID) {
-					__be32 v4addr;
-					struct timeval timer;
-
-					mapfrag_get(idx, &isdefrag4, &v4addr, &timer);
-
-					if (v4addr == 0) {
-						/* never receive/forward first fragment, drop it */
-						mapfrag_delete(idx);
-						return 0;
-					}
-
-					if (!(ip4h->frag_off & htons(IP_MF)))
-						mapfrag_delete(idx);
-				}
-			}
-
-			if (ip4h->protocol == IPPROTO_ICMP || isdefrag4) {
-				/* 
-				 * receive fragmented ICMP:
-				 * Need to reassemble it before processing.
-				 */
-				local_bh_disable();
-				err = ip_defrag(skb, IP_DEFRAG_MAP);
-				local_bh_enable();
-
-				if (!err) {
-					ip_send_check(ip_hdr(skb));
-					skb->ignore_df = 1;
-					ip4h = ip_hdr(skb);
-				}
-				else
-					return NF_STOLEN;
+			/* 
+			 * receive fragmented ICMP:
+			 * Need to reassemble it before processing.
+			*/
+			local_bh_disable();
+			err = ip_defrag(skb, IP_DEFRAG_MAP);
+			local_bh_enable();
+
+			if (!err) {
+				ip_send_check(ip_hdr(skb));
+				skb->ignore_df = 1;
+				ip4h = ip_hdr(skb);
 			}
+			else
+				return NF_STOLEN;
 		}
 	}
 
 	plen = ntohs(ip4h->tot_len) - (ip4h->ihl * 4);
 	payload = (__u8 *)(ip4h) + (ip4h->ihl << 2);
 	s_port = d_port = newp = 0;
-	transport = 0;
 	flag_udp_nullcheck = 0;
+	orig_dev = skb->dev;
 
 	/*
 	 * RFC 6145:
@@ -572,7 +540,7 @@
 			u32 dst_mtu;
 
 			//MTU for LAN = WAN MTU - extra 20 or 40 in ipv6 header - frag header 8 byte
-			dst_mtu = (u32)mtu - (hgw_transport == MAP_T ? 20 : 40) - 8;
+			dst_mtu = (u32)mtu - (transport == MAP_T ? 20 : 40) - (transport == MAP_T ? 8 : (extension ? 8 : 0));
 			send_icmp_frag(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(dst_mtu));
 			return 0;
 		}
@@ -580,28 +548,28 @@
 	}
 	else if (ip4h->frag_off == 0)
 	{
-		if ((hgw_transport == MAP_T ? plen : ntohs(ip4h->tot_len)) + sizeof(struct ipv6hdr) + sizeof(struct frag_hdr) > mtu)
+		if ((transport == MAP_T ? plen : ntohs(ip4h->tot_len)) + sizeof(struct ipv6hdr) + (transport == MAP_T ? sizeof(struct frag_hdr) : (extension ? 8 : 0)) > mtu)
 			frag_mode = 2;
 		else
 			frag_mode = 1;
 	}
 	else
 	{
-		if (ip4h->protocol == IPPROTO_ICMP) {
+		if (transport == MAP_E || ip4h->protocol == IPPROTO_ICMP) {
 			/* should not happen, we reassemble at beginning */
 			return 0;
 		}
 
-		if ((hgw_transport == MAP_T ? plen : ntohs(ip4h->tot_len)) + sizeof(struct ipv6hdr) + sizeof(struct frag_hdr) > mtu)
+		if (plen + sizeof(struct ipv6hdr) + sizeof(struct frag_hdr) > mtu)
 			frag_mode = 2;
 		else
 			frag_mode = 3;
 	}
 
-	if (hgw_transport == MAP_T)
+	if (transport == MAP_T)
 		mss_limit = mtu - 40 - 8 - 20; //ipv6(40) frag(8) tcp(20)
 	else
-		mss_limit = mtu - 40 - 8 - 20 - 20; //ipv6(40) dest(8) ipv4(20) tcp(20)
+		mss_limit = mtu - 40 - (extension ? 8 : 0) - 20 - 20; //ipv6(40) dest(8) ipv4(20) tcp(20)
 
 	if (!(ip4h->frag_off & htons(IP_OFFSET)))
 	{
@@ -619,11 +587,7 @@
 				}
 			}
 			
-#if 1 //Tung NAT44
 			if (ivi_mode == IVI_MODE_HGW && ntohs(tcph->source) < 1024) {
-#else
-			if (((ivi_mode == IVI_MODE_HGW) || (ivi_mode == IVI_MODE_HGW_NAT44)) && ntohs(tcph->dest) < 1024) {
-#endif
 				newp = ntohs(tcph->source);
 			}
 			
@@ -659,11 +623,7 @@
 			if (udph->check == 0) 
 				flag_udp_nullcheck = 1;
 			
-#if 1 //Tung NAT44
 			if (ivi_mode == IVI_MODE_HGW && ntohs(udph->source) < 1024) {
-#else
-			if (((ivi_mode == IVI_MODE_HGW) || (ivi_mode == IVI_MODE_HGW_NAT44)) && ntohs(udph->dest) < 1024) {
-#endif
 				newp = ntohs(udph->source);
 			}
 			
@@ -725,8 +685,17 @@
 				}
 				s_port = d_port = ntohs(icmph->un.echo.id);
 				
+			} else if (icmph->type == ICMP_DEST_UNREACH) {
+				if (ivi_mode == IVI_MODE_HGW_NAT44) {
+					csum_replace4(&ip4h->check, ip4h->saddr, htonl(v4publicaddr));
+					ip4h->saddr = htonl(v4publicaddr);
+				}
+				s_port = d_port = ntohs(icmph->un.echo.id);
+
 			} else {
+#ifdef IVI_DEBUG
 				printk(KERN_ERR "ivi_v4v6_xmit: unsupported ICMP type in NAT44. Drop packet now.\n");
+#endif
 				return 0;
 			}
 
@@ -741,7 +710,7 @@
 	else
 	{
 		if (ivi_mode == IVI_MODE_HGW_NAT44) {
-			if (hgw_transport == MAP_E) {
+			if (transport == MAP_E) {
 				csum_replace4(&ip4h->check, ip4h->saddr, htonl(v4publicaddr));
 			}
 			ip4h->saddr = htonl(v4publicaddr);
@@ -749,7 +718,7 @@
 	}
 
 	hlen = sizeof(struct ipv6hdr);
-	if (!(newskb = dev_alloc_skb(2 + ETH_HLEN + hlen + ntohs(ip4h->tot_len) + 8/* dest(8) */))) {
+	if (!(newskb = dev_alloc_skb(2 + ETH_HLEN + hlen + ntohs(ip4h->tot_len) + 8/* frag(8) or dest(8) */))) {
 		// Allocation size is enough for both E and T;
 		// Even in ICMP translation case, it's enough for two IP headers' translation. 
 		printk(KERN_ERR "ivi_v4v6_xmit: failed to allocate new socket buffer.\n");
@@ -809,35 +778,27 @@
 	
 	if (transport == MAP_E) {
 		// Encapsulation
-		ip6h->payload_len = htons(ntohs(ip4h->tot_len) + 8/* dest(8) */);
+		ip6h->payload_len = extension ? htons(ntohs(ip4h->tot_len) + 8/* dest(8) */) : ip4h->tot_len;
 		plen = ntohs(ip4h->tot_len);
-		ip6h->nexthdr = IPPROTO_IPIP; // 4
+		ip6h->nexthdr = IPPROTO_IPIP;
 		ip6h->hop_limit = 64 + 1; // we have to put translated IPv6 packet into the protocol stack again
-
-		if (frag_mode == 3)
-		{
-			csum_replace2(&ip4h->check, ip4h->id, htons(newp));
-			ip4h->id = htons(newp);
+		if (extension) {
+			// Making Destination Options Header, constant and 8 bytes long
+			fh = (struct frag_hdr *)skb_put(newskb, sizeof(struct frag_hdr));
+			*(__u64 *)fh = __constant_cpu_to_be64(0x0000040104010100); // dest(8)
+			fh->nexthdr = ip6h->nexthdr;
+			ip6h->nexthdr = NEXTHDR_DEST;
 		}
-
-		// Making Destination Options Header, constant and 8 bytes long
-		fh = (struct frag_hdr *)skb_put(newskb, sizeof(struct frag_hdr));
-		*(__u64 *)fh = __constant_cpu_to_be64(0x0000040104010100); // dest(8)
-
 		payload = (__u8 *)skb_put(newskb, plen);
 		skb_copy_bits(skb, 0, payload, plen);
-		fh->nexthdr = ip6h->nexthdr;
-		ip6h->nexthdr = NEXTHDR_DEST;
 
-		if (frag_mode == 1 || frag_mode == 3)
-		{
-			newskb->map_forward = MAP_FORWARD_MODE1;
-		}
-		else if (frag_mode == 2)
+		if (frag_mode == 2)
 		{
 			newskb->map_id = htons(newp);
 			newskb->map_forward = MAP_FORWARD_MODE3;
-		}
+		} 
+		else
+			newskb->map_forward = MAP_FORWARD_MODE1;
 	} 
 	
 	else {
@@ -873,7 +834,7 @@
 		else
 			ip6h->payload_len = htons(plen);
 
-		payload = (__u8 *)skb_put(newskb, plen);
+		payload = (__u8 *)skb_put(newskb, plen+(hlen-sizeof(struct iphdr)));
 		if (!(ip4h->frag_off & htons(IP_OFFSET)))
 		{
 		switch (ip6h->nexthdr) {
@@ -952,19 +913,185 @@
 				skb_copy_bits(skb, ip4h->ihl * 4, payload, 4); // ICMPv6 header length
 				icmp6h = (struct icmp6hdr *)payload;
 				
-				if (icmp6h->icmp6_type == ICMP_ECHO || icmp6h->icmp6_type == ICMP_ECHOREPLY) {
+				if (icmp6h->icmp6_type == ICMP_ECHO || icmp6h->icmp6_type == ICMP_ECHOREPLY || icmp6h->icmp6_type == ICMP_DEST_UNREACH) {
+					__u8 icmp_type = icmp6h->icmp6_type;
+
+					if (icmp_type == ICMP_DEST_UNREACH)
+					{
+						__u8 icmp_code = icmp6h->icmp6_code;
+						unsigned int dlen = plen - 8;
+
+						skb_copy_bits(skb, (ip4h->ihl << 2) + 4, payload + 4, 4); // Unused (or MTU) length
+
+						switch (icmp_code) {
+							case ICMP_NET_UNREACH:
+							case ICMP_HOST_UNREACH:
+							case ICMP_SR_FAILED:
+							case ICMP_NET_UNKNOWN:
+							case ICMP_HOST_UNKNOWN:
+							case ICMP_HOST_ISOLATED:
+							case ICMP_NET_UNR_TOS:
+							case ICMP_HOST_UNR_TOS:
+								icmp6h->icmp6_type = ICMPV6_DEST_UNREACH;
+								icmp6h->icmp6_code = ICMPV6_NOROUTE;
+								break;
+
+							case ICMP_NET_ANO:
+							case ICMP_HOST_ANO:
+							case ICMP_PKT_FILTERED:
+							case ICMP_PREC_CUTOFF:
+								icmp6h->icmp6_type = ICMPV6_DEST_UNREACH;
+								icmp6h->icmp6_code = ICMPV6_ADM_PROHIBITED;
+								break;
+
+							case ICMP_PORT_UNREACH:
+								icmp6h->icmp6_type = ICMPV6_DEST_UNREACH;
+								icmp6h->icmp6_code = ICMPV6_PORT_UNREACH;
+								break;
+
+							case ICMP_PROT_UNREACH:
+								icmp6h->icmp6_type = ICMPV6_PARAMPROB;
+								icmp6h->icmp6_code = ICMPV6_UNK_NEXTHDR;
+								icmp6h->icmp6_pointer = htonl(ip6h->nexthdr); //FIXME
+								break;
+
+							case ICMP_FRAG_NEEDED:
+								icmp6h->icmp6_type = ICMPV6_PKT_TOOBIG;
+								icmp6h->icmp6_code = 0;
+								//FIXME: if mtu isn't the MTU_of_IPv6_nexthop or _mtu isn't the MTU_of_IPv4_nexthop
+								icmp6h->icmp6_mtu = htonl(max((unsigned int)IPV6_MIN_MTU, \
+								                  min((ntohl(icmp6h->icmp6_mtu) & 0x00ff) + (hlen-(ip4h->ihl * 4)), min(mtu, _mtu + (hlen-(ip4h->ihl * 4))))));
+								break;
+
+							case ICMP_PREC_VIOLATION:
+							default:
+								kfree_skb(newskb);
+								return 0;
+						}
+
+						if (dlen >= sizeof(struct iphdr) + 8)
+						{
+							struct iphdr *icmp_ip4h;
+							struct ipv6hdr *icmp_ip6h;
+							struct tcphdr *icmp_tcph;
+							struct udphdr *icmp_udph;
+							struct icmp6hdr *icmp_icmp6h;
+							__u8 *icmp_payload;
+							u16 icmp_newp = 0;
+
+							// translation of ipv4 header embeded in icmpv4
+							icmp_ip4h = (struct iphdr *)((__u8 *)icmph + 8); //skb
+							icmp_ip6h = (struct ipv6hdr *)((__u8 *)icmp6h + sizeof(struct icmp6hdr)); //newskb
+							ip6_flow_hdr(icmp_ip6h, icmp_ip4h->tos, 0);
+
+							icmp_ip6h->hop_limit = icmp_ip4h->ttl;
+							icmp_ip6h->nexthdr = icmp_ip4h->protocol;
+							ipaddr_4to6(&(icmp_ip4h->daddr), s_port, ADDR_DIR_SRC, &(icmp_ip6h->daddr), NULL);
+							ipaddr_4to6(&(icmp_ip4h->saddr), d_port, ADDR_DIR_DST, &(icmp_ip6h->saddr), &transport);
+							icmp_payload = (__u8 *)icmp_ip6h + hlen;
+
+							ip6h->payload_len = htons(ntohs(ip6h->payload_len)+(hlen-(icmp_ip4h->ihl * 4)));
+							icmp_ip6h->payload_len = htons(ntohs(icmp_ip4h->tot_len) - (icmp_ip4h->ihl * 4));
+							skb_copy_bits(skb, (ip4h->ihl << 2) + 8 + sizeof(struct iphdr), icmp_payload,\
+								              ntohs(icmp_ip6h->payload_len)); // Error message length
+
+							switch (icmp_ip6h->nexthdr) {
+								case IPPROTO_TCP:
+									icmp_tcph = (struct tcphdr *)icmp_payload;
+									get_outflow_map_port(&tcp_list, ntohl(icmp_ip4h->daddr), ntohs(icmp_tcph->dest), \
+									    ntohl(icmp_ip4h->saddr), hgw_ratio, hgw_adjacent, hgw_offset, &icmp_newp, skb);
+
+									if (icmp_newp == 0) { // Many ICMP packets have an uncomplete inside TCP structure:
+									                      // return value is -1 alone cannot imply a fail lookup.
+										//printk(KERN_ERR "ivi_v4v6_xmit: tcp-in-icmp reverse lookup failure.\n");
+								
+									} else {
+										icmp_ip6h->daddr = ip6h->saddr;
+										icmp_tcph->dest = htons(icmp_newp);
+									}
+									icmp_tcph->check = 0;
+									icmp_tcph->check = csum_ipv6_magic(&(icmp_ip6h->saddr), &(icmp_ip6h->daddr), \
+									                       ntohs(icmp_ip6h->payload_len), IPPROTO_TCP, \
+									                       csum_partial(icmp_tcph, ntohs(icmp_ip6h->payload_len), 0));
+									break;
+								case IPPROTO_UDP:
+									icmp_udph = (struct udphdr *)icmp_payload;
+									if (get_outflow_map_port(&udp_list, ntohl(icmp_ip4h->daddr), ntohs(icmp_udph->dest), \
+									                         ntohl(icmp_ip4h->saddr), hgw_ratio, hgw_adjacent, hgw_offset, &icmp_newp, skb) == -1) {
+										//printk(KERN_ERR "ivi_v4v6_xmit: udp-in-icmp reverse lookup failure.\n");
+								
+									} else {
+										icmp_ip6h->daddr = ip6h->saddr;
+										icmp_udph->dest = htons(icmp_newp);
+									}
+									icmp_udph->len = icmp_ip6h->payload_len;
+									icmp_udph->check = 0;
+									icmp_udph->check = csum_ipv6_magic(&(icmp_ip6h->saddr), &(icmp_ip6h->daddr), \
+									                       ntohs(icmp_ip6h->payload_len), IPPROTO_UDP, \
+									                       csum_partial(icmp_udph, ntohs(icmp_ip6h->payload_len), 0));
+									break;
+								case IPPROTO_ICMP:
+									icmp_ip6h->nexthdr = IPPROTO_ICMPV6;
+									icmp_icmp6h = (struct icmp6hdr *)icmp_payload;
+									if (icmp_icmp6h->icmp6_type == ICMP_ECHO || icmp_icmp6h->icmp6_type == ICMP_ECHOREPLY) {
+										icmp_icmp6h->icmp6_type=(icmp_icmp6h->icmp6_type==ICMP_ECHO)?ICMPV6_ECHO_REQUEST:ICMPV6_ECHO_REPLY;
+										if (get_outflow_map_port(&icmp_list, ntohl(icmp_ip4h->daddr), ntohs(icmp_icmp6h->icmp6_identifier), \
+										                         ntohl(icmp_ip4h->saddr), hgw_ratio, hgw_adjacent, hgw_offset, &icmp_newp, skb) == -1) {
+											//printk(KERN_ERR "ivi_v4v6_xmit: echo-in-icmp reverse lookup failure.\n");
+										} else {
+											icmp_ip6h->daddr = ip6h->saddr;
+											icmp_icmp6h->icmp6_identifier = htons(icmp_newp);
+										}
+										icmp_icmp6h->icmp6_cksum = 0;
+										icmp_icmp6h->icmp6_cksum = csum_ipv6_magic(&(icmp_ip6h->saddr), &(icmp_ip6h->daddr), \
+										                               ntohs(icmp_ip6h->payload_len), IPPROTO_ICMPV6, \
+										                               csum_partial(icmp_icmp6h, ntohs(icmp_ip6h->payload_len), 0));
+									}
+									break;
+								default:
+									break;
+							}
+						}
+						else if (dlen == 0)
+						{
+#ifdef IVI_DEBUG
+							printk(KERN_INFO "ivi_v4v6_xmit: no ICMP message found (Type=%d, Code=%d).\n", \
+							                  icmp_type, icmp_code);
+#endif
+							// we're here because of the cdrouter mapt_custom_1003_ICMP_Translation.
+						}
+						else
+						{
+							//printk(KERN_ERR "ivi_v4v6_xmit: malformed ICMP message in xlate. Drop packet.\n");
+							kfree_skb(newskb);
+							return 0;
+						}
+					}
+					else
+					{
 					skb_copy_bits(skb, ip4h->ihl * 4 + 4, payload + 4, plen - 4);
-					if (icmp6h->icmp6_type == ICMP_ECHO)
+					if (icmp_type == ICMP_ECHO)
 						icmp6h->icmp6_type = ICMPV6_ECHO_REQUEST;
 					else
 						icmp6h->icmp6_type = ICMPV6_ECHO_REPLY;
+					}
 					
 					if (!(ip4h->frag_off & htons(IP_MF)))
 					{
 					icmp6h->icmp6_cksum = 0;
+					if (icmp_type == ICMP_DEST_UNREACH)
+					{
+						unsigned int dlen = plen - 8;
+						struct iphdr *icmp_ip4h = (struct iphdr *)((__u8 *)icmph + 8);
+						icmp6h->icmp6_cksum = csum_ipv6_magic(&(ip6h->saddr), &(ip6h->daddr), dlen ? plen + (hlen-(icmp_ip4h->ihl * 4)) : plen, \
+					                              IPPROTO_ICMPV6, csum_partial(payload, dlen ? plen + (hlen-(icmp_ip4h->ihl * 4)) : plen, 0));
+					}
+					else
+					{
 					icmp6h->icmp6_cksum = csum_ipv6_magic(&(ip6h->saddr), &(ip6h->daddr), plen, \
 					                            IPPROTO_ICMPV6, csum_partial(payload, plen, 0));
 					}
+					}
 					else
 					{
 						u16 csum16;
@@ -1032,16 +1159,12 @@
 	}
 
 	// Prepare to re-enter the protocol stack
-	newskb->protocol = eth_type_trans(newskb, skb->dev);
+	newskb->protocol = eth_type_trans(newskb, orig_dev);
 	newskb->ip_summed = CHECKSUM_NONE;
 
 #if defined(CONFIG_BCM_KF_BLOG) && defined(CONFIG_BLOG)
 		blog_xfer(newskb, skb);
 #endif
-#ifdef IVI_DEBUG //TungYu
-		printk(KERN_INFO "ivi_v4v6_xmit: v6_src " NIP6_FMT " !!! v6_dst " NIP6_FMT " ~~ v4_src " NIP4_FMT " !!! v4_dst " NIP4_FMT "\
-			\n", NIP6(ip6h->saddr), NIP6(ip6h->daddr), NIP4(ip4h->saddr), NIP4(ip4h->daddr));
-#endif
 
 	netif_rx(newskb);
 	return 0;
@@ -1175,6 +1298,9 @@
 			if ((ip4h->frag_off & htons(IP_MF)) || (ip4h->frag_off & htons(IP_OFFSET))) {
 				int err;
 
+				memcpy(skb_mac_header(skb) + poffset, skb_mac_header(skb), ETH_HLEN);
+				skb->mac_header += poffset;
+				skb->transport_header += ip4h->ihl << 2;
 				skb_pull(skb, poffset);
 				skb_reset_network_header(skb);
 
@@ -1202,7 +1328,7 @@
 
 	if (!(newskb = dev_alloc_skb(2 + ETH_HLEN + max(hlen + plen, 184) + 20))) {
 		printk(KERN_ERR "ivi_v6v4_xmit: failed to allocate new socket buffer.\n");
-		return 0;  // Drop packet on low memory
+		goto out;  // Drop packet on low memory
 	}
 	
 	if (next_hdr == IPPROTO_IPIP) { // Decapsulation
@@ -1219,14 +1345,10 @@
 					//printk(KERN_INFO "ivi_v6v4_xmit: TCP dest port %d is not in range (r=%d, m=%d, o=%d)."
 					//                 "Drop packet.\n", ntohs(tcph->dest), hgw_ratio, hgw_adjacent, hgw_offset);
 					kfree_skb(newskb);
-					return 0;
+					goto out;
 				}
 				
-#if 0 //Tung NAT44
 				if (ivi_mode == IVI_MODE_HGW && ntohs(tcph->dest) < 1024) {
-#else
-				if (((ivi_mode == IVI_MODE_HGW) || (ivi_mode == IVI_MODE_HGW_NAT44)) && ntohs(tcph->dest) < 1024) {
-#endif
 					oldaddr = ntohl(ip4h->daddr);
 					oldp = ntohs(tcph->dest);
 				}
@@ -1241,7 +1363,7 @@
 					//printk(KERN_ERR "ivi_v6v4_xmit: fail to perform nat44 mapping for %d (TCP).\n",
 					//	               ntohs(tcph->dest));
 					kfree_skb(newskb);
-					return 0;
+					goto out;
 				}
 						
 				csum_replace4(&tcph->check, ip4h->daddr, htonl(oldaddr));
@@ -1270,14 +1392,10 @@
 					//printk(KERN_INFO "ivi_v6v4_xmit: UDP dest port %d is not in range (r=%d, m=%d, o=%d)."
 					//                 "Drop packet.\n", ntohs(udph->dest), hgw_ratio, hgw_adjacent, hgw_offset);
 					kfree_skb(newskb);
-					return 0;
+					goto out;
 				}
 				
-#if 0 //Tung NAT44
 				if (ivi_mode == IVI_MODE_HGW && ntohs(udph->dest) < 1024) {
-#else
-				if (((ivi_mode == IVI_MODE_HGW) || (ivi_mode == IVI_MODE_HGW_NAT44)) && ntohs(udph->dest) < 1024) {
-#endif
 					oldaddr = ntohl(ip4h->daddr);
 					oldp = ntohs(udph->dest);
 				}
@@ -1287,7 +1405,7 @@
 					//printk(KERN_ERR "ivi_v6v4_xmit: fail to perform nat44 mapping for %d (UDP).\n",
 					//                 ntohs(udph->dest));	
 					kfree_skb(newskb);
-					return 0;
+					goto out;
 				}
 				
 				// If checksum of UDP inside IPv4 packet is 0, we MUST NOT update the checksum value.
@@ -1311,7 +1429,7 @@
 						printk(KERN_ERR "ivi_v6v4_xmit: fail to perform nat44 mapping for ( " NIP4_FMT \
 						                ", %d) (ICMP).\n", NIP4(tempaddr), ntohs(icmph->un.echo.id));
 						kfree_skb(newskb);
-						return 0;
+						goto out;
 					} else {
 						csum_replace4(&ip4h->check, ip4h->daddr, htonl(oldaddr));
 						ip4h->daddr = htonl(oldaddr);
@@ -1325,7 +1443,8 @@
 #ifdef IVI_DEBUG
 						printk(KERN_INFO "ivi_v6v4_xmit: you can't ping private address when CPE is working in NAT44 mode\n");
 #endif
-						return 0; // silently drop
+						kfree_skb(newskb);
+						goto out; // silently drop
 					}
 				} 
 				else if (icmph->type == ICMP_TIME_EXCEEDED || icmph->type == ICMP_DEST_UNREACH) {
@@ -1337,11 +1456,13 @@
 							oldaddr = oldp = 0;
 							get_inflow_map_port(&tcp_list, ntohs(icmp_tcph->source), \
 							               ntohl(icmp_ip4h->daddr), &oldaddr, &oldp, skb);
-							if (oldaddr == 0 && oldp == 0) // Many ICMP packets have an uncomplete inside TCP structure:
-							                               // return value is -1 alone cannot imply a fail lookup.
+							if (oldaddr == 0 && oldp == 0) { // Many ICMP packets have an uncomplete inside TCP structure:
+							                                 // return value is -1 alone cannot imply a fail lookup.
+#ifdef IVI_DEBUG
 								printk(KERN_ERR "ivi_v6v4_xmit: fail to perform nat44 mapping for %d (TCP) "\
 								                "in IP packet.\n", ntohs(icmp_tcph->source));
-							else {
+#endif
+							} else {
 								csum_replace4(&icmp_tcph->check, icmp_ip4h->saddr, htonl(oldaddr));
 								csum_replace4(&icmp_ip4h->check, icmp_ip4h->saddr, htonl(oldaddr));
 								csum_replace4(&ip4h->check, ip4h->daddr, htonl(oldaddr));
@@ -1354,8 +1475,10 @@
 							icmp_udph = (struct udphdr *)((__u8 *)icmp_ip4h + (icmp_ip4h->ihl << 2));
 							if (get_inflow_map_port(&udp_list, ntohs(icmp_udph->source), \
 							                   ntohl(icmp_ip4h->daddr), &oldaddr, &oldp, skb) == -1) {
+#ifdef IVI_DEBUG
 								printk(KERN_ERR "ivi_v6v4_xmit: fail to perform nat44 mapping for %d (UDP) "\
 								                "in IP packet.\n", ntohs(icmp_udph->source));
+#endif
 								kfree_skb(newskb);
 								return 0;
 							} else {
@@ -1372,8 +1495,10 @@
 							if (icmp_icmp4h->type == ICMP_ECHO) {
 								if (get_inflow_map_port(&icmp_list, ntohs(icmp_icmp4h->un.echo.id), \
 								                   ntohl(icmp_ip4h->daddr), &oldaddr, &oldp, skb) == -1) {
+#ifdef IVI_DEBUG
 									printk(KERN_ERR "ivi_v6v4_xmit: fail to perform nat44 mapping for %d (ICMP) "\
 									                "in IP packet.\n", ntohs(icmp_icmp4h->un.echo.id));
+#endif
 									kfree_skb(newskb);
 									return 0;
 								} else {
@@ -1394,7 +1519,7 @@
 
 			default:
 				kfree_skb(newskb);
-				return 0;
+				goto out;
 		}
 	} 
 	
@@ -1409,10 +1534,6 @@
 			return -EINVAL;  // Just accept.
 		}
 
-#ifdef IVI_DEBUG //TungYu
-		printk(KERN_INFO "after Tran v6_src " NIP6_FMT " !!! v6_dst " NIP6_FMT " ~~ v4_src " NIP4_FMT " !!! v4_dst " NIP4_FMT "\
-			\n", NIP6(ip6h->saddr), NIP6(ip6h->daddr), NIP4(ip4h->saddr), NIP4(ip4h->daddr));
-#endif
 		*(__u16 *)ip4h = __constant_htons(0x4500);
 		ip4h->tot_len = htons(hlen + plen);
 		
@@ -1462,11 +1583,7 @@
 					return 0;
 				}
 				
-#if 0 //Tung NAT44
 				if (ivi_mode == IVI_MODE_HGW && ntohs(tcph->dest) < 1024) {
-#else
-				if (((ivi_mode == IVI_MODE_HGW) || (ivi_mode == IVI_MODE_HGW_NAT44)) && ntohs(tcph->dest) < 1024) {
-#endif
 					oldaddr = ntohl(ip4h->daddr);
 					oldp = ntohs(tcph->dest);
 				}
@@ -1549,11 +1666,7 @@
 					return 0;
 				}
 					
-#if 0 //Tung NAT44
 				if (ivi_mode == IVI_MODE_HGW && ntohs(udph->dest) < 1024) {
-#else
-				if (((ivi_mode == IVI_MODE_HGW) || (ivi_mode == IVI_MODE_HGW_NAT44)) && ntohs(udph->dest) < 1024) {
-#endif
 					oldaddr = ntohl(ip4h->daddr);
 					oldp = ntohs(udph->dest);
 				}
@@ -1614,6 +1727,8 @@
 						                        &oldaddr, &oldp, skb) == -1) {
 							//printk(KERN_INFO "ivi_v6v4_xmit: fail to perform nat44 mapping for %d (ICMP).\n", 
 							//                ntohs(icmph->un.echo.id));
+							kfree_skb(newskb);
+							goto out;
 						} else {
 							ip4h->daddr = htonl(oldaddr);
 							icmph->un.echo.id = htons(oldp);
@@ -1636,6 +1751,7 @@
 					}
 					else {
 						//printk(KERN_ERR "ivi_v6v4_xmit: unsupported ICMP type. Drop Packet now.\n");
+						kfree_skb(newskb);
 						return 0;
 					}
 					
@@ -1673,11 +1789,11 @@
 							                        &oldaddr, &oldp, skb);
 #endif
 							    
-							if (oldaddr == 0 && oldp == 0) // Many ICMP packets have an uncomplete inside TCP structure:
-							                               // return value is -1 alone cannot imply a fail lookup. 
-								printk(KERN_ERR "ivi_v6v4_xmit: tcp-in-icmp reverse lookup failure.\n");
+							if (oldaddr == 0 && oldp == 0) { // Many ICMP packets have an uncomplete inside TCP structure:
+							                                 // return value is -1 alone cannot imply a fail lookup. 
+								//printk(KERN_ERR "ivi_v6v4_xmit: tcp-in-icmp reverse lookup failure.\n");
 								
-							else {
+							} else {
 								icmp_ip4h->saddr = ip4h->daddr = htonl(oldaddr);
 								icmp_tcph->source = htons(oldp);
 							}
@@ -1690,7 +1806,7 @@
 							icmp_udph = (struct udphdr *)((__u8 *)icmp_ip4h + 20);
 							if (get_inflow_map_port(&udp_list, ntohs(icmp_udph->source), ntohl(icmp_ip4h->daddr), \
 							                        &oldaddr, &oldp, skb) == -1) {
-								printk(KERN_ERR "ivi_v6v4_xmit: udp-in-icmp reverse lookup failure.\n");
+								//printk(KERN_ERR "ivi_v6v4_xmit: udp-in-icmp reverse lookup failure.\n");
 								
 							} else {
 								icmp_ip4h->saddr = ip4h->daddr = htonl(oldaddr);
@@ -1708,9 +1824,9 @@
 							if (icmp_icmp4h->type == ICMPV6_ECHO_REQUEST || icmp_icmp4h->type == ICMPV6_ECHO_REPLY) {
 								icmp_icmp4h->type=(icmp_icmp4h->type==ICMPV6_ECHO_REQUEST)?ICMP_ECHO:ICMP_ECHOREPLY;
 								if (get_inflow_map_port(&icmp_list, ntohs(icmp_icmp4h->un.echo.id), \
-								                        ntohl(icmp_ip4h->daddr), &oldaddr, &oldp, skb) == -1)
-									printk(KERN_ERR "ivi_v6v4_xmit: echo-in-icmp reverse lookup failure.\n");
-								else {
+								                        ntohl(icmp_ip4h->daddr), &oldaddr, &oldp, skb) == -1) {
+									//printk(KERN_ERR "ivi_v6v4_xmit: echo-in-icmp reverse lookup failure.\n");
+								} else {
 									icmp_ip4h->saddr = ip4h->daddr = htonl(oldaddr);
 									icmp_icmp4h->un.echo.id = htons(oldp);
 								}
@@ -1739,21 +1855,26 @@
 			ipid = ntohl(fragh->identification);
 			if ((idx = mapfrag_lookup(&(ip6h->saddr), ipid)) != MAPFRAG_IX_INVALID)
 			{
-				mapfrag_set(idx, 0, htonl(oldaddr));
+				mapfrag_set(idx, htonl(oldaddr));
+			}
+			else
+			{
+				kfree_skb(newskb);
+				return 0;
 			}
 		}
 
 		}
 		else if (fragh && off4)
 		{
-			u32 idx, ipid, isdefrag4;
+			u32 idx, ipid;
 			__be32 v4addr;
 			struct timeval timer;
 
 			ipid = ntohl(fragh->identification);
 			if ((idx = mapfrag_lookup(&(ip6h->saddr), ipid)) != MAPFRAG_IX_INVALID)
 			{
-				mapfrag_get(idx, &isdefrag4, &v4addr, &timer);
+				mapfrag_get(idx, &v4addr, &timer);
 				if (v4addr == 0)
 				{
 					/* never receive/forward first fragment, drop it */
@@ -1762,6 +1883,11 @@
 					return 0;
 				}
 			}
+			else
+			{
+				kfree_skb(newskb);
+				return 0;
+			}
 
 			skb_copy_bits(skb, poffset, payload, plen);
 			ip4h->daddr = v4addr;
@@ -1785,12 +1911,9 @@
 		blog_xfer(newskb, skb);
 #endif
  
-#ifdef IVI_DEBUG //TungYu
-		printk(KERN_INFO "ivi_v6v4_xmit: v6_src " NIP6_FMT " !!! v6_dst " NIP6_FMT " ~~ v4_src " NIP4_FMT " !!! v4_dst " NIP4_FMT "\
-			\n", NIP6(ip6h->saddr), NIP6(ip6h->daddr), NIP4(ip4h->saddr), NIP4(ip4h->daddr));
-#endif
 	netif_rx(newskb);
 
+out:
 	if (!frag_icmpv6)
 		return 0;
 	else {
Index: ivi-1.0/ivi_xmit.h
===================================================================
--- ivi-1.0.orig/ivi_xmit.h	2020-02-11 03:33:39.726453739 +0000
+++ ivi-1.0/ivi_xmit.h	2020-02-11 03:33:52.278453619 +0000
@@ -76,10 +76,11 @@
 
 extern u8 hgw_fmt;
 extern u8 hgw_transport;
+extern u8 hgw_extension;
 
 extern u16 mss_limit;
 
-extern int ivi_v4v6_xmit(struct sk_buff *skb, unsigned int mtu);
+extern int ivi_v4v6_xmit(struct sk_buff *skb, unsigned int mtu, unsigned int _mtu);
 extern int ivi_v6v4_xmit(struct sk_buff *skb);
 extern int ivi_v4_dev(struct net_device *dev);
 extern int ivi_v6_dev(struct net_device *dev);
Index: ivi-1.0/Makefile
===================================================================
--- ivi-1.0.orig/Makefile	2020-02-11 03:26:37.310457767 +0000
+++ ivi-1.0/Makefile	2019-07-29 19:43:47.000000000 +0000
@@ -1,11 +1,12 @@
-obj-m		+=	ivi.o
-#ivi-objs	:=	ivi_rule.o ivi_rule6.o ivi_map.o ivi_map_tcp.o ivi_xmit.o ivi_nf.o ivi_ioctl.o ivi_module.o
-ivi-objs	:=	ivi_rule.o ivi_rule6.o ivi_map.o ivi_xmit.o ivi_nf.o ivi_ioctl.o ivi_module.o ivi_portmap.o
-#KERNELDIR	:=	/lib/modules/$(shell uname -r)/build
-PWD		:=	$(shell pwd)
+#ivi-objs    :=  ivi_rule.o ivi_rule6.o ivi_map.o ivi_map_tcp.o ivi_xmit.o ivi_nf.o ivi_ioctl.o ivi_module.o ivi_portmap.o
+ivi-objs    :=  ivi_rule.o ivi_rule6.o ivi_map.o ivi_xmit.o ivi_nf.o ivi_ioctl.o ivi_module.o ivi_portmap.o
 
-all:
-	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+obj-$(CONFIG_BCM_MAP) += ivi.o
+
+EXTRA_CFLAGS += -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+EXTRA_CFLAGS += -I$(INC_BRCMSHARED_PUB_PATH)/$(BRCM_BOARD)
+EXTRA_CFLAGS += -Werror -Wall
 
 clean:
-	rm -rf *.ko *.o *.mod.c core Module.symvers Module.markers modules.order .*.cmd .tmp_versions
+	rm -f core *.o *.a *.s .*.cmd *.ko
+
